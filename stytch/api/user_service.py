# !!!
# WARNING: This file is autogenerated
# Only modify code within MANUAL() sections
# or your changes may be overwritten later!
# !!!

from typing import Any, Dict, List, Optional, Union

import pydantic

from stytch.core.api_base import ApiBase
from stytch.core.http.client import AsyncClient, SyncClient
from stytch.models.user_service import (
    CreateuserResponse,
    DeleteuserbiometricregistrationResponse,
    DeleteusercryptowalletResponse,
    DeleteuseremailResponse,
    DeleteuseroauthuserregistrationResponse,
    DeleteuserpasswordResponse,
    DeleteuserphonenumberResponse,
    DeleteuserResponse,
    DeleteusertotpResponse,
    DeleteuserwebauthnregistrationResponse,
    GetpendingusersResponse,
    GetuserbyemailandprojectidResponse,
    GetuserResponse,
    SearchusersexternalResponse,
    UpdateuserResponse,
)


class UserService:
    def __init__(
      self,
      api_base: ApiBase,
      sync_client: SyncClient,
      async_client: AsyncClient,
    ) -> None:
        self.api_base = api_base
        self.sync_client = sync_client
        self.async_client = async_client

    @property
    def sub_url(self) -> str:
        return "user_service"

    def CreateUser(
        self,
        email: Optional[str] = None,
        name: None,
        attributes: Optional[Dict[str, str]] = None,
        phone_number: Optional[str] = None,
        create_user_as_pending: bool,
        trusted_metadata: Optional[Dict[str, Any]] = None,
        untrusted_metadata: Optional[Dict[str, Any]] = None,
    ) -> CreateuserResponse:

        payload: Dict[str, Any] = {
            "create_user_as_pending": create_user_as_pending,
        }

        if email is not None:
            payload["email"] = email
        if name is not None:
            payload["name"] = name
        if attributes is not None:
            payload["attributes"] = attributes
        if phone_number is not None:
            payload["phone_number"] = phone_number
        if trusted_metadata is not None:
            payload["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            payload["untrusted_metadata"] = untrusted_metadata

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users")

        res = self.sync_client.post(url, json=payload)
        return CreateuserResponse.from_json(res.response.status_code, res.json)

    async def CreateUser_async(
      self,
      email: Optional[str] = None,
      name: None,
      attributes: Optional[Dict[str, str]] = None,
      phone_number: Optional[str] = None,
      create_user_as_pending: bool,
      trusted_metadata: Optional[Dict[str, Any]] = None,
      untrusted_metadata: Optional[Dict[str, Any]] = None,
    ) -> CreateuserResponse:

        payload: Dict[str, Any] = {
            "create_user_as_pending": create_user_as_pending,
        }

        if email is not None:
            payload["email"] = email
        if name is not None:
            payload["name"] = name
        if attributes is not None:
            payload["attributes"] = attributes
        if phone_number is not None:
            payload["phone_number"] = phone_number
        if trusted_metadata is not None:
            payload["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            payload["untrusted_metadata"] = untrusted_metadata

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users")

        res = await self.async_client.post(url, json=payload)
        return CreateuserResponse.from_json(res.response.status, res.json)

    def GetPendingUsers(
        self,
        starting_after_id: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> GetpendingusersResponse:

        payload: Dict[str, Any] = {
        }

        if starting_after_id is not None:
            payload["starting_after_id"] = starting_after_id
        if limit is not None:
            payload["limit"] = limit

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/pending")

        res = self.sync_client.get(url, params=payload)
        return GetpendingusersResponse.from_json(res.response.status_code, res.json)

    async def GetPendingUsers_async(
      self,
      starting_after_id: Optional[str] = None,
      limit: Optional[int] = None,
    ) -> GetpendingusersResponse:

        payload: Dict[str, Any] = {
        }

        if starting_after_id is not None:
            payload["starting_after_id"] = starting_after_id
        if limit is not None:
            payload["limit"] = limit

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/pending")

        res = await self.async_client.get(url, params=payload)
        return GetpendingusersResponse.from_json(res.response.status, res.json)

    def GetUser(
        self,
        user_id: str,
    ) -> GetuserResponse:

        payload: Dict[str, Any] = {
            "user_id": user_id,
        }


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/{user_id}")

        res = self.sync_client.get(url, params=payload)
        return GetuserResponse.from_json(res.response.status_code, res.json)

    async def GetUser_async(
      self,
      user_id: str,
    ) -> GetuserResponse:

        payload: Dict[str, Any] = {
            "user_id": user_id,
        }


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/{user_id}")

        res = await self.async_client.get(url, params=payload)
        return GetuserResponse.from_json(res.response.status, res.json)

    def SearchUsersExternal(
        self,
        cursor: str,
        limit: Optional[int] = None,
        SearchUsersExternalQuery: None,
        operands: None,
    ) -> SearchusersexternalResponse:

        payload: Dict[str, Any] = {
            "cursor": cursor,
        }

        if limit is not None:
            payload["limit"] = limit
        if SearchUsersExternalQuery is not None:
            payload["SearchUsersExternalQuery"] = SearchUsersExternalQuery
        if operands is not None:
            payload["operands"] = operands

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/search")

        res = self.sync_client.post(url, json=payload)
        return SearchusersexternalResponse.from_json(res.response.status_code, res.json)

    async def SearchUsersExternal_async(
      self,
      cursor: str,
      limit: Optional[int] = None,
      SearchUsersExternalQuery: None,
      operands: None,
    ) -> SearchusersexternalResponse:

        payload: Dict[str, Any] = {
            "cursor": cursor,
        }

        if limit is not None:
            payload["limit"] = limit
        if SearchUsersExternalQuery is not None:
            payload["SearchUsersExternalQuery"] = SearchUsersExternalQuery
        if operands is not None:
            payload["operands"] = operands

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/search")

        res = await self.async_client.post(url, json=payload)
        return SearchusersexternalResponse.from_json(res.response.status, res.json)

    def UpdateUser(
        self,
        user_id: str,
        name: None,
        emails: None,
        attributes: Optional[Dict[str, str]] = None,
        phone_numbers: None,
        crypto_wallets: None,
        trusted_metadata: Optional[Dict[str, Any]] = None,
        untrusted_metadata: Optional[Dict[str, Any]] = None,
    ) -> UpdateuserResponse:

        payload: Dict[str, Any] = {
            "user_id": user_id,
        }

        if name is not None:
            payload["name"] = name
        if emails is not None:
            payload["emails"] = emails
        if attributes is not None:
            payload["attributes"] = attributes
        if phone_numbers is not None:
            payload["phone_numbers"] = phone_numbers
        if crypto_wallets is not None:
            payload["crypto_wallets"] = crypto_wallets
        if trusted_metadata is not None:
            payload["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            payload["untrusted_metadata"] = untrusted_metadata

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/{user_id}")

        res = self.sync_client.put(url, json=payload)
        return UpdateuserResponse.from_json(res.response.status_code, res.json)

    async def UpdateUser_async(
      self,
      user_id: str,
      name: None,
      emails: None,
      attributes: Optional[Dict[str, str]] = None,
      phone_numbers: None,
      crypto_wallets: None,
      trusted_metadata: Optional[Dict[str, Any]] = None,
      untrusted_metadata: Optional[Dict[str, Any]] = None,
    ) -> UpdateuserResponse:

        payload: Dict[str, Any] = {
            "user_id": user_id,
        }

        if name is not None:
            payload["name"] = name
        if emails is not None:
            payload["emails"] = emails
        if attributes is not None:
            payload["attributes"] = attributes
        if phone_numbers is not None:
            payload["phone_numbers"] = phone_numbers
        if crypto_wallets is not None:
            payload["crypto_wallets"] = crypto_wallets
        if trusted_metadata is not None:
            payload["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            payload["untrusted_metadata"] = untrusted_metadata

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/{user_id}")

        res = await self.async_client.put(url, json=payload)
        return UpdateuserResponse.from_json(res.response.status, res.json)

    def DeleteUser(
        self,
        user_id: str,
    ) -> DeleteuserResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/{user_id}")

        res = self.sync_client.delete(url)
        return DeleteuserResponse.from_json(res.response.status_code, res.json)

    async def DeleteUser_async(
      self,
      user_id: str,
    ) -> DeleteuserResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/{user_id}")

        res = await self.async_client.delete(url)
        return DeleteuserResponse.from_json(res.response.status, res.json)

    def GetUserByEmailAndProjectID(
        self,
        email: str,
        project_id: str,
    ) -> GetuserbyemailandprojectidResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "project_id": project_id,
        }


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/sdk/users")

        res = self.sync_client.get(url, params=payload)
        return GetuserbyemailandprojectidResponse.from_json(res.response.status_code, res.json)

    async def GetUserByEmailAndProjectID_async(
      self,
      email: str,
      project_id: str,
    ) -> GetuserbyemailandprojectidResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "project_id": project_id,
        }


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/sdk/users")

        res = await self.async_client.get(url, params=payload)
        return GetuserbyemailandprojectidResponse.from_json(res.response.status, res.json)

    def DeleteUserEmail(
        self,
        email_id: str,
    ) -> DeleteuseremailResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/emails/{email_id}")

        res = self.sync_client.delete(url)
        return DeleteuseremailResponse.from_json(res.response.status_code, res.json)

    async def DeleteUserEmail_async(
      self,
      email_id: str,
    ) -> DeleteuseremailResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/emails/{email_id}")

        res = await self.async_client.delete(url)
        return DeleteuseremailResponse.from_json(res.response.status, res.json)

    def DeleteUserPhoneNumber(
        self,
        phone_id: str,
    ) -> DeleteuserphonenumberResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/phone_numbers/{phone_id}")

        res = self.sync_client.delete(url)
        return DeleteuserphonenumberResponse.from_json(res.response.status_code, res.json)

    async def DeleteUserPhoneNumber_async(
      self,
      phone_id: str,
    ) -> DeleteuserphonenumberResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/phone_numbers/{phone_id}")

        res = await self.async_client.delete(url)
        return DeleteuserphonenumberResponse.from_json(res.response.status, res.json)

    def DeleteUserWebAuthnRegistration(
        self,
        webauthn_registration_id: str,
    ) -> DeleteuserwebauthnregistrationResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/webauthn_registrations/{webauthn_registration_id}")

        res = self.sync_client.delete(url)
        return DeleteuserwebauthnregistrationResponse.from_json(res.response.status_code, res.json)

    async def DeleteUserWebAuthnRegistration_async(
      self,
      webauthn_registration_id: str,
    ) -> DeleteuserwebauthnregistrationResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/webauthn_registrations/{webauthn_registration_id}")

        res = await self.async_client.delete(url)
        return DeleteuserwebauthnregistrationResponse.from_json(res.response.status, res.json)

    def DeleteUserBiometricRegistration(
        self,
        biometric_registration_id: str,
    ) -> DeleteuserbiometricregistrationResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/biometric_registrations/{biometric_registration_id}")

        res = self.sync_client.delete(url)
        return DeleteuserbiometricregistrationResponse.from_json(res.response.status_code, res.json)

    async def DeleteUserBiometricRegistration_async(
      self,
      biometric_registration_id: str,
    ) -> DeleteuserbiometricregistrationResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/biometric_registrations/{biometric_registration_id}")

        res = await self.async_client.delete(url)
        return DeleteuserbiometricregistrationResponse.from_json(res.response.status, res.json)

    def DeleteUserTOTP(
        self,
        totp_id: str,
    ) -> DeleteusertotpResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/totps/{totp_id}")

        res = self.sync_client.delete(url)
        return DeleteusertotpResponse.from_json(res.response.status_code, res.json)

    async def DeleteUserTOTP_async(
      self,
      totp_id: str,
    ) -> DeleteusertotpResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/totps/{totp_id}")

        res = await self.async_client.delete(url)
        return DeleteusertotpResponse.from_json(res.response.status, res.json)

    def DeleteUserCryptoWallet(
        self,
        crypto_wallet_id: str,
    ) -> DeleteusercryptowalletResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/crypto_wallets/{crypto_wallet_id}")

        res = self.sync_client.delete(url)
        return DeleteusercryptowalletResponse.from_json(res.response.status_code, res.json)

    async def DeleteUserCryptoWallet_async(
      self,
      crypto_wallet_id: str,
    ) -> DeleteusercryptowalletResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/crypto_wallets/{crypto_wallet_id}")

        res = await self.async_client.delete(url)
        return DeleteusercryptowalletResponse.from_json(res.response.status, res.json)

    def DeleteUserPassword(
        self,
        password_id: str,
    ) -> DeleteuserpasswordResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/passwords/{password_id}")

        res = self.sync_client.delete(url)
        return DeleteuserpasswordResponse.from_json(res.response.status_code, res.json)

    async def DeleteUserPassword_async(
      self,
      password_id: str,
    ) -> DeleteuserpasswordResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/passwords/{password_id}")

        res = await self.async_client.delete(url)
        return DeleteuserpasswordResponse.from_json(res.response.status, res.json)

    def DeleteUserOAuthUserRegistration(
        self,
        oauth_user_registration_id: str,
    ) -> DeleteuseroauthuserregistrationResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/oauth/{oauth_user_registration_id}")

        res = self.sync_client.delete(url)
        return DeleteuseroauthuserregistrationResponse.from_json(res.response.status_code, res.json)

    async def DeleteUserOAuthUserRegistration_async(
      self,
      oauth_user_registration_id: str,
    ) -> DeleteuseroauthuserregistrationResponse:


        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/users/oauth/{oauth_user_registration_id}")

        res = await self.async_client.delete(url)
        return DeleteuseroauthuserregistrationResponse.from_json(res.response.status, res.json)

