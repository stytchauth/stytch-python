# !!!
# WARNING: This file is autogenerated
# Only modify code within MANUAL() sections
# or your changes may be overwritten later!
# !!!

from typing import Any, Dict, List, Optional, Union

import pydantic

from stytch.core.api_base import ApiBase
from stytch.core.http.client import AsyncClient, SyncClient
from stytch.models.password_service import (
    PasswordsauthenticateResponse,
    PasswordscreateResponse,
    PasswordsemailresetResponse,
    PasswordsemailresetstartResponse,
    PasswordsexistingpasswordresetResponse,
    PasswordsmigrateResponse,
    PasswordssessionresetResponse,
    PasswordsstrengthcheckResponse,
)


class PasswordService:
    def __init__(
      self,
      api_base: ApiBase,
      sync_client: SyncClient,
      async_client: AsyncClient,
    ) -> None:
        self.api_base = api_base
        self.sync_client = sync_client
        self.async_client = async_client

    @property
    def sub_url(self) -> str:
        return "password_service"

    def PasswordsCreate(
        self,
        email: str,
        password: str,
        session_duration_minutes: Optional[int] = None,
        session_custom_claims: Optional[Dict[str, Any]] = None,
        trusted_metadata: Optional[Dict[str, Any]] = None,
        untrusted_metadata: Optional[Dict[str, Any]] = None,
        name: None,
    ) -> PasswordscreateResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "password": password,
        }

        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims
        if trusted_metadata is not None:
            payload["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            payload["untrusted_metadata"] = untrusted_metadata
        if name is not None:
            payload["name"] = name

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords")

        res = self.sync_client.post(url, json=payload)
        return PasswordscreateResponse.from_json(res.response.status_code, res.json)

    async def PasswordsCreate_async(
      self,
      email: str,
      password: str,
      session_duration_minutes: Optional[int] = None,
      session_custom_claims: Optional[Dict[str, Any]] = None,
      trusted_metadata: Optional[Dict[str, Any]] = None,
      untrusted_metadata: Optional[Dict[str, Any]] = None,
      name: None,
    ) -> PasswordscreateResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "password": password,
        }

        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims
        if trusted_metadata is not None:
            payload["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            payload["untrusted_metadata"] = untrusted_metadata
        if name is not None:
            payload["name"] = name

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords")

        res = await self.async_client.post(url, json=payload)
        return PasswordscreateResponse.from_json(res.response.status, res.json)

    def PasswordsAuthenticate(
        self,
        email: str,
        password: str,
        session_token: Optional[str] = None,
        session_duration_minutes: Optional[int] = None,
        session_jwt: Optional[str] = None,
        session_custom_claims: Optional[Dict[str, Any]] = None,
    ) -> PasswordsauthenticateResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "password": password,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/authenticate")

        res = self.sync_client.post(url, json=payload)
        return PasswordsauthenticateResponse.from_json(res.response.status_code, res.json)

    async def PasswordsAuthenticate_async(
      self,
      email: str,
      password: str,
      session_token: Optional[str] = None,
      session_duration_minutes: Optional[int] = None,
      session_jwt: Optional[str] = None,
      session_custom_claims: Optional[Dict[str, Any]] = None,
    ) -> PasswordsauthenticateResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "password": password,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/authenticate")

        res = await self.async_client.post(url, json=payload)
        return PasswordsauthenticateResponse.from_json(res.response.status, res.json)

    def PasswordsEmailResetStart(
        self,
        email: str,
        reset_password_redirect_url: str,
        reset_password_expiration_minutes: Optional[int] = None,
        code_challenge: Optional[str] = None,
        attributes: Optional[Dict[str, str]] = None,
        login_redirect_url: str,
        locale: Optional[str] = None,
        reset_password_template_id: Optional[str] = None,
    ) -> PasswordsemailresetstartResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "reset_password_redirect_url": reset_password_redirect_url,
            "login_redirect_url": login_redirect_url,
        }

        if reset_password_expiration_minutes is not None:
            payload["reset_password_expiration_minutes"] = reset_password_expiration_minutes
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if attributes is not None:
            payload["attributes"] = attributes
        if locale is not None:
            payload["locale"] = locale
        if reset_password_template_id is not None:
            payload["reset_password_template_id"] = reset_password_template_id

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/email/reset/start")

        res = self.sync_client.post(url, json=payload)
        return PasswordsemailresetstartResponse.from_json(res.response.status_code, res.json)

    async def PasswordsEmailResetStart_async(
      self,
      email: str,
      reset_password_redirect_url: str,
      reset_password_expiration_minutes: Optional[int] = None,
      code_challenge: Optional[str] = None,
      attributes: Optional[Dict[str, str]] = None,
      login_redirect_url: str,
      locale: Optional[str] = None,
      reset_password_template_id: Optional[str] = None,
    ) -> PasswordsemailresetstartResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "reset_password_redirect_url": reset_password_redirect_url,
            "login_redirect_url": login_redirect_url,
        }

        if reset_password_expiration_minutes is not None:
            payload["reset_password_expiration_minutes"] = reset_password_expiration_minutes
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if attributes is not None:
            payload["attributes"] = attributes
        if locale is not None:
            payload["locale"] = locale
        if reset_password_template_id is not None:
            payload["reset_password_template_id"] = reset_password_template_id

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/email/reset/start")

        res = await self.async_client.post(url, json=payload)
        return PasswordsemailresetstartResponse.from_json(res.response.status, res.json)

    def PasswordsEmailReset(
        self,
        token: str,
        password: str,
        session_token: Optional[str] = None,
        session_duration_minutes: Optional[int] = None,
        session_jwt: Optional[str] = None,
        code_verifier: Optional[str] = None,
        session_custom_claims: Optional[Dict[str, Any]] = None,
        attributes: Optional[Dict[str, str]] = None,
        options: Optional[Dict[str, str]] = None,
    ) -> PasswordsemailresetResponse:

        payload: Dict[str, Any] = {
            "token": token,
            "password": password,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if code_verifier is not None:
            payload["code_verifier"] = code_verifier
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims
        if attributes is not None:
            payload["attributes"] = attributes
        if options is not None:
            payload["options"] = options

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/email/reset")

        res = self.sync_client.post(url, json=payload)
        return PasswordsemailresetResponse.from_json(res.response.status_code, res.json)

    async def PasswordsEmailReset_async(
      self,
      token: str,
      password: str,
      session_token: Optional[str] = None,
      session_duration_minutes: Optional[int] = None,
      session_jwt: Optional[str] = None,
      code_verifier: Optional[str] = None,
      session_custom_claims: Optional[Dict[str, Any]] = None,
      attributes: Optional[Dict[str, str]] = None,
      options: Optional[Dict[str, str]] = None,
    ) -> PasswordsemailresetResponse:

        payload: Dict[str, Any] = {
            "token": token,
            "password": password,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if code_verifier is not None:
            payload["code_verifier"] = code_verifier
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims
        if attributes is not None:
            payload["attributes"] = attributes
        if options is not None:
            payload["options"] = options

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/email/reset")

        res = await self.async_client.post(url, json=payload)
        return PasswordsemailresetResponse.from_json(res.response.status, res.json)

    def PasswordsExistingPasswordReset(
        self,
        email: str,
        existing_password: str,
        new_password: str,
        session_token: Optional[str] = None,
        session_duration_minutes: Optional[int] = None,
        session_jwt: Optional[str] = None,
        session_custom_claims: Optional[Dict[str, Any]] = None,
    ) -> PasswordsexistingpasswordresetResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "existing_password": existing_password,
            "new_password": new_password,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/existing_password/reset")

        res = self.sync_client.post(url, json=payload)
        return PasswordsexistingpasswordresetResponse.from_json(res.response.status_code, res.json)

    async def PasswordsExistingPasswordReset_async(
      self,
      email: str,
      existing_password: str,
      new_password: str,
      session_token: Optional[str] = None,
      session_duration_minutes: Optional[int] = None,
      session_jwt: Optional[str] = None,
      session_custom_claims: Optional[Dict[str, Any]] = None,
    ) -> PasswordsexistingpasswordresetResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "existing_password": existing_password,
            "new_password": new_password,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/existing_password/reset")

        res = await self.async_client.post(url, json=payload)
        return PasswordsexistingpasswordresetResponse.from_json(res.response.status, res.json)

    def PasswordsSessionReset(
        self,
        password: str,
        session_token: Optional[str] = None,
        session_jwt: Optional[str] = None,
    ) -> PasswordssessionresetResponse:

        payload: Dict[str, Any] = {
            "password": password,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/session/reset")

        res = self.sync_client.post(url, json=payload)
        return PasswordssessionresetResponse.from_json(res.response.status_code, res.json)

    async def PasswordsSessionReset_async(
      self,
      password: str,
      session_token: Optional[str] = None,
      session_jwt: Optional[str] = None,
    ) -> PasswordssessionresetResponse:

        payload: Dict[str, Any] = {
            "password": password,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/session/reset")

        res = await self.async_client.post(url, json=payload)
        return PasswordssessionresetResponse.from_json(res.response.status, res.json)

    def PasswordsMigrate(
        self,
        email: str,
        hash: str,
        hash_type: str,
        md_5_config: None,
        argon_2_config: None,
        sha_1_config: None,
        scrypt_config: None,
        first_name: str,
        last_name: str,
        trusted_metadata: Optional[Dict[str, Any]] = None,
        untrusted_metadata: Optional[Dict[str, Any]] = None,
        set_email_verified: bool,
    ) -> PasswordsmigrateResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "hash": hash,
            "hash_type": hash_type,
            "first_name": first_name,
            "last_name": last_name,
            "set_email_verified": set_email_verified,
        }

        if md_5_config is not None:
            payload["md_5_config"] = md_5_config
        if argon_2_config is not None:
            payload["argon_2_config"] = argon_2_config
        if sha_1_config is not None:
            payload["sha_1_config"] = sha_1_config
        if scrypt_config is not None:
            payload["scrypt_config"] = scrypt_config
        if trusted_metadata is not None:
            payload["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            payload["untrusted_metadata"] = untrusted_metadata

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/migrate")

        res = self.sync_client.post(url, json=payload)
        return PasswordsmigrateResponse.from_json(res.response.status_code, res.json)

    async def PasswordsMigrate_async(
      self,
      email: str,
      hash: str,
      hash_type: str,
      md_5_config: None,
      argon_2_config: None,
      sha_1_config: None,
      scrypt_config: None,
      first_name: str,
      last_name: str,
      trusted_metadata: Optional[Dict[str, Any]] = None,
      untrusted_metadata: Optional[Dict[str, Any]] = None,
      set_email_verified: bool,
    ) -> PasswordsmigrateResponse:

        payload: Dict[str, Any] = {
            "email": email,
            "hash": hash,
            "hash_type": hash_type,
            "first_name": first_name,
            "last_name": last_name,
            "set_email_verified": set_email_verified,
        }

        if md_5_config is not None:
            payload["md_5_config"] = md_5_config
        if argon_2_config is not None:
            payload["argon_2_config"] = argon_2_config
        if sha_1_config is not None:
            payload["sha_1_config"] = sha_1_config
        if scrypt_config is not None:
            payload["scrypt_config"] = scrypt_config
        if trusted_metadata is not None:
            payload["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            payload["untrusted_metadata"] = untrusted_metadata

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/migrate")

        res = await self.async_client.post(url, json=payload)
        return PasswordsmigrateResponse.from_json(res.response.status, res.json)

    def PasswordsStrengthCheck(
        self,
        password: str,
        email: Optional[str] = None,
    ) -> PasswordsstrengthcheckResponse:

        payload: Dict[str, Any] = {
            "password": password,
        }

        if email is not None:
            payload["email"] = email

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/strength_check")

        res = self.sync_client.post(url, json=payload)
        return PasswordsstrengthcheckResponse.from_json(res.response.status_code, res.json)

    async def PasswordsStrengthCheck_async(
      self,
      password: str,
      email: Optional[str] = None,
    ) -> PasswordsstrengthcheckResponse:

        payload: Dict[str, Any] = {
            "password": password,
        }

        if email is not None:
            payload["email"] = email

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/passwords/strength_check")

        res = await self.async_client.post(url, json=payload)
        return PasswordsstrengthcheckResponse.from_json(res.response.status, res.json)

