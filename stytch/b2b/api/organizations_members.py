# !!!
# WARNING: This file is autogenerated
# Only modify code within MANUAL() sections
# or your changes may be overwritten later!
# !!!

from __future__ import annotations

from typing import Any, Dict, List, Optional

from stytch.b2b.models.organizations import SearchQuery
from stytch.b2b.models.organizations_members import (
    CreateRequestOptions,
    CreateResponse,
    DeleteMFAPhoneNumberRequestOptions,
    DeleteMFAPhoneNumberResponse,
    DeletePasswordRequestOptions,
    DeletePasswordResponse,
    DeleteRequestOptions,
    DeleteResponse,
    GetResponse,
    ReactivateRequestOptions,
    ReactivateResponse,
    SearchRequestOptions,
    SearchResponse,
    UpdateRequestOptions,
    UpdateResponse,
)
from stytch.core.api_base import ApiBase
from stytch.core.http.client import AsyncClient, SyncClient


class Members:
    def __init__(
        self, api_base: ApiBase, sync_client: SyncClient, async_client: AsyncClient
    ) -> None:
        self.api_base = api_base
        self.sync_client = sync_client
        self.async_client = async_client

    def update(
        self,
        organization_id: str,
        member_id: str,
        name: Optional[str] = None,
        trusted_metadata: Optional[Dict[str, Any]] = None,
        untrusted_metadata: Optional[Dict[str, Any]] = None,
        is_breakglass: Optional[bool] = None,
        mfa_phone_number: Optional[str] = None,
        mfa_enrolled: Optional[bool] = None,
        roles: Optional[List[str]] = None,
        preserve_existing_sessions: Optional[bool] = None,
        method_options: Optional[UpdateRequestOptions] = None,
    ) -> UpdateResponse:
        """Updates a Member specified by `organization_id` and `member_id`.

        (Coming Soon) Our RBAC implementation offers out-of-the-box handling of authorization checks for this endpoint. If you pass in
        a header containing a `session_token` or a `session_jwt` for an unexpired Member Session, we will check that the
        Member Session has the necessary permissions. The specific permissions needed depend on which of the optional fields
        are passed in the request. For example, if the `organization_name` argument is provided, the Member Session must have
        permission to perform the `update.info.name` action on the `stytch.organization` Resource.

        If the Member Session does not contain a Role that satisfies the requested permissions, or if the Member's Organization
        does not match the `organization_id` passed in the request, a 403 error will be thrown. Otherwise, the request will
        proceed as normal.

        To learn more about our RBAC implementation, see our [RBAC guide](https://stytch.com/docs/b2b/guides/rbac/overview).

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
          - name: The name of the Member.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.info.name` action on the `stytch.member` Resource.
          Alternatively, if the Member Session matches the Member associated with the `member_id` passed in the request, the authorization check will also allow a Member Session that has permission to perform the `update.info.name` action on the `stytch.self` Resource.
          - trusted_metadata: An arbitrary JSON object for storing application-specific data or identity-provider-specific data.
                  If a session header is passed into the request, this field may **not** be passed into the request. You cannot
                  update trusted metadata when acting as a Member.
          - untrusted_metadata: An arbitrary JSON object of application-specific data. These fields can be edited directly by the
          frontend SDK, and should not be used to store critical information. See the [Metadata resource](https://stytch.com/docs/b2b/api/metadata)
          for complete field behavior details.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.info.untrusted-metadata` action on the `stytch.member` Resource.
          Alternatively, if the Member Session matches the Member associated with the `member_id` passed in the request, the authorization check will also allow a Member Session that has permission to perform the `update.info.untrusted-metadata` action on the `stytch.self` Resource.
          - is_breakglass: Identifies the Member as a break glass user - someone who has permissions to authenticate into an Organization by bypassing the Organization's settings. A break glass account is typically used for emergency purposes to gain access outside of normal authentication procedures. Refer to the [Organization object](organization-object) and its `auth_methods` and `allowed_auth_methods` fields for more details.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.info.is-breakglass` action on the `stytch.member` Resource.
          - mfa_phone_number: Sets the Member's phone number. Throws an error if the Member already has a phone number. To change the Member's phone number, use the [Delete member phone number endpoint](https://stytch.com/docs/b2b/api/delete-member-mfa-phone-number) to delete the Member's existing phone number first.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.info.mfa-phone` action on the `stytch.member` Resource.
          Alternatively, if the Member Session matches the Member associated with the `member_id` passed in the request, the authorization check will also allow a Member Session that has permission to perform the `update.info.mfa-phone` action on the `stytch.self` Resource.
          - mfa_enrolled: Sets whether the Member is enrolled in MFA. If true, the Member must complete an MFA step whenever they wish to log in to their Organization. If false, the Member only needs to complete an MFA step if the Organization's MFA policy is set to `REQUIRED_FOR_ALL`.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.settings.mfa-enrolled` action on the `stytch.member` Resource.
          Alternatively, if the Member Session matches the Member associated with the `member_id` passed in the request, the authorization check will also allow a Member Session that has permission to perform the `update.settings.mfa-enrolled` action on the `stytch.self` Resource.
          - roles: (Coming Soon) Roles to explicitly assign to this Member.
         Will completely replace any existing explicitly assigned roles. See the
         [RBAC guide](https://stytch.com/docs/b2b/guides/rbac/role-assignment) for more information about role assignment.

           If a Role is removed from a Member, and the Member is also implicitly assigned this Role from an SSO connection
           or an SSO group, we will by default revoke any existing sessions for the Member that contain any SSO
           authentication factors with the affected connection ID. You can preserve these sessions by passing in the
           `preserve_existing_sessions` parameter with a value of `true`.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.settings.roles` action on the `stytch.member` Resource.
          - preserve_existing_sessions: (Coming Soon) Whether to preserve existing sessions when explicit Roles that are revoked are also implicitly assigned
          by SSO connection or SSO group. Defaults to `false` - that is, existing Member Sessions that contain SSO
          authentication factors with the affected SSO connection IDs will be revoked.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_id": member_id,
        }
        if name is not None:
            data["name"] = name
        if trusted_metadata is not None:
            data["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            data["untrusted_metadata"] = untrusted_metadata
        if is_breakglass is not None:
            data["is_breakglass"] = is_breakglass
        if mfa_phone_number is not None:
            data["mfa_phone_number"] = mfa_phone_number
        if mfa_enrolled is not None:
            data["mfa_enrolled"] = mfa_enrolled
        if roles is not None:
            data["roles"] = roles
        if preserve_existing_sessions is not None:
            data["preserve_existing_sessions"] = preserve_existing_sessions

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/{member_id}", data
        )
        res = self.sync_client.put(url, data, headers)
        return UpdateResponse.from_json(res.response.status_code, res.json)

    async def update_async(
        self,
        organization_id: str,
        member_id: str,
        name: Optional[str] = None,
        trusted_metadata: Optional[Dict[str, Any]] = None,
        untrusted_metadata: Optional[Dict[str, Any]] = None,
        is_breakglass: Optional[bool] = None,
        mfa_phone_number: Optional[str] = None,
        mfa_enrolled: Optional[bool] = None,
        roles: Optional[List[str]] = None,
        preserve_existing_sessions: Optional[bool] = None,
        method_options: Optional[UpdateRequestOptions] = None,
    ) -> UpdateResponse:
        """Updates a Member specified by `organization_id` and `member_id`.

        (Coming Soon) Our RBAC implementation offers out-of-the-box handling of authorization checks for this endpoint. If you pass in
        a header containing a `session_token` or a `session_jwt` for an unexpired Member Session, we will check that the
        Member Session has the necessary permissions. The specific permissions needed depend on which of the optional fields
        are passed in the request. For example, if the `organization_name` argument is provided, the Member Session must have
        permission to perform the `update.info.name` action on the `stytch.organization` Resource.

        If the Member Session does not contain a Role that satisfies the requested permissions, or if the Member's Organization
        does not match the `organization_id` passed in the request, a 403 error will be thrown. Otherwise, the request will
        proceed as normal.

        To learn more about our RBAC implementation, see our [RBAC guide](https://stytch.com/docs/b2b/guides/rbac/overview).

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
          - name: The name of the Member.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.info.name` action on the `stytch.member` Resource.
          Alternatively, if the Member Session matches the Member associated with the `member_id` passed in the request, the authorization check will also allow a Member Session that has permission to perform the `update.info.name` action on the `stytch.self` Resource.
          - trusted_metadata: An arbitrary JSON object for storing application-specific data or identity-provider-specific data.
                  If a session header is passed into the request, this field may **not** be passed into the request. You cannot
                  update trusted metadata when acting as a Member.
          - untrusted_metadata: An arbitrary JSON object of application-specific data. These fields can be edited directly by the
          frontend SDK, and should not be used to store critical information. See the [Metadata resource](https://stytch.com/docs/b2b/api/metadata)
          for complete field behavior details.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.info.untrusted-metadata` action on the `stytch.member` Resource.
          Alternatively, if the Member Session matches the Member associated with the `member_id` passed in the request, the authorization check will also allow a Member Session that has permission to perform the `update.info.untrusted-metadata` action on the `stytch.self` Resource.
          - is_breakglass: Identifies the Member as a break glass user - someone who has permissions to authenticate into an Organization by bypassing the Organization's settings. A break glass account is typically used for emergency purposes to gain access outside of normal authentication procedures. Refer to the [Organization object](organization-object) and its `auth_methods` and `allowed_auth_methods` fields for more details.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.info.is-breakglass` action on the `stytch.member` Resource.
          - mfa_phone_number: Sets the Member's phone number. Throws an error if the Member already has a phone number. To change the Member's phone number, use the [Delete member phone number endpoint](https://stytch.com/docs/b2b/api/delete-member-mfa-phone-number) to delete the Member's existing phone number first.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.info.mfa-phone` action on the `stytch.member` Resource.
          Alternatively, if the Member Session matches the Member associated with the `member_id` passed in the request, the authorization check will also allow a Member Session that has permission to perform the `update.info.mfa-phone` action on the `stytch.self` Resource.
          - mfa_enrolled: Sets whether the Member is enrolled in MFA. If true, the Member must complete an MFA step whenever they wish to log in to their Organization. If false, the Member only needs to complete an MFA step if the Organization's MFA policy is set to `REQUIRED_FOR_ALL`.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.settings.mfa-enrolled` action on the `stytch.member` Resource.
          Alternatively, if the Member Session matches the Member associated with the `member_id` passed in the request, the authorization check will also allow a Member Session that has permission to perform the `update.settings.mfa-enrolled` action on the `stytch.self` Resource.
          - roles: (Coming Soon) Roles to explicitly assign to this Member.
         Will completely replace any existing explicitly assigned roles. See the
         [RBAC guide](https://stytch.com/docs/b2b/guides/rbac/role-assignment) for more information about role assignment.

           If a Role is removed from a Member, and the Member is also implicitly assigned this Role from an SSO connection
           or an SSO group, we will by default revoke any existing sessions for the Member that contain any SSO
           authentication factors with the affected connection ID. You can preserve these sessions by passing in the
           `preserve_existing_sessions` parameter with a value of `true`.

        If this field is provided and a session header is passed into the request, the Member Session must have permission to perform the `update.settings.roles` action on the `stytch.member` Resource.
          - preserve_existing_sessions: (Coming Soon) Whether to preserve existing sessions when explicit Roles that are revoked are also implicitly assigned
          by SSO connection or SSO group. Defaults to `false` - that is, existing Member Sessions that contain SSO
          authentication factors with the affected SSO connection IDs will be revoked.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_id": member_id,
        }
        if name is not None:
            data["name"] = name
        if trusted_metadata is not None:
            data["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            data["untrusted_metadata"] = untrusted_metadata
        if is_breakglass is not None:
            data["is_breakglass"] = is_breakglass
        if mfa_phone_number is not None:
            data["mfa_phone_number"] = mfa_phone_number
        if mfa_enrolled is not None:
            data["mfa_enrolled"] = mfa_enrolled
        if roles is not None:
            data["roles"] = roles
        if preserve_existing_sessions is not None:
            data["preserve_existing_sessions"] = preserve_existing_sessions

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/{member_id}", data
        )
        res = await self.async_client.put(url, data, headers)
        return UpdateResponse.from_json(res.response.status, res.json)

    def delete(
        self,
        organization_id: str,
        member_id: str,
        method_options: Optional[DeleteRequestOptions] = None,
    ) -> DeleteResponse:
        """Deletes a Member specified by `organization_id` and `member_id`. /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_id": member_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/{member_id}", data
        )
        res = self.sync_client.delete(url, headers)
        return DeleteResponse.from_json(res.response.status_code, res.json)

    async def delete_async(
        self,
        organization_id: str,
        member_id: str,
        method_options: Optional[DeleteRequestOptions] = None,
    ) -> DeleteResponse:
        """Deletes a Member specified by `organization_id` and `member_id`. /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_id": member_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/{member_id}", data
        )
        res = await self.async_client.delete(url, headers)
        return DeleteResponse.from_json(res.response.status, res.json)

    def reactivate(
        self,
        organization_id: str,
        member_id: str,
        method_options: Optional[ReactivateRequestOptions] = None,
    ) -> ReactivateResponse:
        """Reactivates a deleted Member's status and its associated email status (if applicable) to active, specified by `organization_id` and `member_id`. /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_id": member_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/{member_id}/reactivate",
            data,
        )
        res = self.sync_client.put(url, data, headers)
        return ReactivateResponse.from_json(res.response.status_code, res.json)

    async def reactivate_async(
        self,
        organization_id: str,
        member_id: str,
        method_options: Optional[ReactivateRequestOptions] = None,
    ) -> ReactivateResponse:
        """Reactivates a deleted Member's status and its associated email status (if applicable) to active, specified by `organization_id` and `member_id`. /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_id": member_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/{member_id}/reactivate",
            data,
        )
        res = await self.async_client.put(url, data, headers)
        return ReactivateResponse.from_json(res.response.status, res.json)

    def delete_mfa_phone_number(
        self,
        organization_id: str,
        member_id: str,
        method_options: Optional[DeleteMFAPhoneNumberRequestOptions] = None,
    ) -> DeleteMFAPhoneNumberResponse:
        """Delete a Member's MFA phone number.

        To change a Member's phone number, you must first call this endpoint to delete the existing phone number.

        Existing Member Sessions that include a phone number authentication factor will not be revoked if the phone number is deleted, and MFA will not be enforced until the Member logs in again.
        If you wish to enforce MFA immediately after a phone number is deleted, you can do so by prompting the Member to enter a new phone number
        and calling the [OTP SMS send](https://stytch.com/docs/b2b/api/otp-sms-send) endpoint, then calling the [OTP SMS Authenticate](https://stytch.com/docs/b2b/api/authenticate-otp-sms) endpoint.
         /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_id": member_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/mfa_phone_numbers/{member_id}",
            data,
        )
        res = self.sync_client.delete(url, headers)
        return DeleteMFAPhoneNumberResponse.from_json(
            res.response.status_code, res.json
        )

    async def delete_mfa_phone_number_async(
        self,
        organization_id: str,
        member_id: str,
        method_options: Optional[DeleteMFAPhoneNumberRequestOptions] = None,
    ) -> DeleteMFAPhoneNumberResponse:
        """Delete a Member's MFA phone number.

        To change a Member's phone number, you must first call this endpoint to delete the existing phone number.

        Existing Member Sessions that include a phone number authentication factor will not be revoked if the phone number is deleted, and MFA will not be enforced until the Member logs in again.
        If you wish to enforce MFA immediately after a phone number is deleted, you can do so by prompting the Member to enter a new phone number
        and calling the [OTP SMS send](https://stytch.com/docs/b2b/api/otp-sms-send) endpoint, then calling the [OTP SMS Authenticate](https://stytch.com/docs/b2b/api/authenticate-otp-sms) endpoint.
         /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_id": member_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/mfa_phone_numbers/{member_id}",
            data,
        )
        res = await self.async_client.delete(url, headers)
        return DeleteMFAPhoneNumberResponse.from_json(res.response.status, res.json)

    def search(
        self,
        organization_ids: List[str],
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        query: Optional[SearchQuery] = None,
        method_options: Optional[SearchRequestOptions] = None,
    ) -> SearchResponse:
        """Search for Members within specified Organizations. An array with at least one `organization_id` is required. Submitting an empty `query` returns all non-deleted Members within the specified Organizations.

        *All fuzzy search filters require a minimum of three characters.

        (Coming Soon) Our RBAC implementation offers out-of-the-box handling of authorization checks for this endpoint. If you pass in
        a header containing a `session_token` or a `session_jwt` for an unexpired Member Session, we will check that the
        Member Session has permission to perform the `search` action on the `stytch.member` Resource. In addition, enforcing
        RBAC on this endpoint means that you may only search for Members within the calling Member's Organization, so the
        `organization_ids` argument may only contain the `organization_id` of the Member Session passed in the header.

        If the Member Session does not contain a Role that satisfies the requested permission, or if the `organization_ids`
        argument contains an `organization_id` that the Member Session does not belong to, a 403 error will be thrown.
        Otherwise, the request will proceed as normal.

        To learn more about our RBAC implementation, see our [RBAC guide](https://stytch.com/docs/b2b/guides/rbac/overview).

        Fields:
          - organization_ids: An array of organization_ids. At least one value is required.
          - cursor: The `cursor` field allows you to paginate through your results. Each result array is limited to 1000 results. If your query returns more than 1000 results, you will need to paginate the responses using the `cursor`. If you receive a response that includes a non-null `next_cursor` in the `results_metadata` object, repeat the search call with the `next_cursor` value set to the `cursor` field to retrieve the next page of results. Continue to make search calls until the `next_cursor` in the response is null.
          - limit: The number of search results to return per page. The default limit is 100. A maximum of 1000 results can be returned by a single search request. If the total size of your result set is greater than one page size, you must paginate the response. See the `cursor` field.
          - query: The optional query object contains the operator, i.e. `AND` or `OR`, and the operands that will filter your results. Only an operator is required. If you include no operands, no filtering will be applied. If you include no query object, it will return all Members with no filtering applied.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_ids": organization_ids,
        }
        if cursor is not None:
            data["cursor"] = cursor
        if limit is not None:
            data["limit"] = limit
        if query is not None:
            data["query"] = query.dict()

        url = self.api_base.url_for("/v1/b2b/organizations/members/search", data)
        res = self.sync_client.post(url, data, headers)
        return SearchResponse.from_json(res.response.status_code, res.json)

    async def search_async(
        self,
        organization_ids: List[str],
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        query: Optional[SearchQuery] = None,
        method_options: Optional[SearchRequestOptions] = None,
    ) -> SearchResponse:
        """Search for Members within specified Organizations. An array with at least one `organization_id` is required. Submitting an empty `query` returns all non-deleted Members within the specified Organizations.

        *All fuzzy search filters require a minimum of three characters.

        (Coming Soon) Our RBAC implementation offers out-of-the-box handling of authorization checks for this endpoint. If you pass in
        a header containing a `session_token` or a `session_jwt` for an unexpired Member Session, we will check that the
        Member Session has permission to perform the `search` action on the `stytch.member` Resource. In addition, enforcing
        RBAC on this endpoint means that you may only search for Members within the calling Member's Organization, so the
        `organization_ids` argument may only contain the `organization_id` of the Member Session passed in the header.

        If the Member Session does not contain a Role that satisfies the requested permission, or if the `organization_ids`
        argument contains an `organization_id` that the Member Session does not belong to, a 403 error will be thrown.
        Otherwise, the request will proceed as normal.

        To learn more about our RBAC implementation, see our [RBAC guide](https://stytch.com/docs/b2b/guides/rbac/overview).

        Fields:
          - organization_ids: An array of organization_ids. At least one value is required.
          - cursor: The `cursor` field allows you to paginate through your results. Each result array is limited to 1000 results. If your query returns more than 1000 results, you will need to paginate the responses using the `cursor`. If you receive a response that includes a non-null `next_cursor` in the `results_metadata` object, repeat the search call with the `next_cursor` value set to the `cursor` field to retrieve the next page of results. Continue to make search calls until the `next_cursor` in the response is null.
          - limit: The number of search results to return per page. The default limit is 100. A maximum of 1000 results can be returned by a single search request. If the total size of your result set is greater than one page size, you must paginate the response. See the `cursor` field.
          - query: The optional query object contains the operator, i.e. `AND` or `OR`, and the operands that will filter your results. Only an operator is required. If you include no operands, no filtering will be applied. If you include no query object, it will return all Members with no filtering applied.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_ids": organization_ids,
        }
        if cursor is not None:
            data["cursor"] = cursor
        if limit is not None:
            data["limit"] = limit
        if query is not None:
            data["query"] = query.dict()

        url = self.api_base.url_for("/v1/b2b/organizations/members/search", data)
        res = await self.async_client.post(url, data, headers)
        return SearchResponse.from_json(res.response.status, res.json)

    def delete_password(
        self,
        organization_id: str,
        member_password_id: str,
        method_options: Optional[DeletePasswordRequestOptions] = None,
    ) -> DeletePasswordResponse:
        """Delete a Member's password. /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_password_id: Globally unique UUID that identifies a Member's password.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_password_id": member_password_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/passwords/{member_password_id}",
            data,
        )
        res = self.sync_client.delete(url, headers)
        return DeletePasswordResponse.from_json(res.response.status_code, res.json)

    async def delete_password_async(
        self,
        organization_id: str,
        member_password_id: str,
        method_options: Optional[DeletePasswordRequestOptions] = None,
    ) -> DeletePasswordResponse:
        """Delete a Member's password. /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_password_id: Globally unique UUID that identifies a Member's password.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "member_password_id": member_password_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members/passwords/{member_password_id}",
            data,
        )
        res = await self.async_client.delete(url, headers)
        return DeletePasswordResponse.from_json(res.response.status, res.json)

    def dangerously_get(
        self,
        member_id: str,
    ) -> GetResponse:
        """Get a Member by `member_id`. This endpoint does not require an `organization_id`, enabling you to get members across organizations. This is a dangerous operation. Incorrect use may open you up to indirect object reference (IDOR) attacks. We recommend using the [Get Member](https://stytch.com/docs/b2b/api/get-member) API instead.

        Fields:
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
        """  # noqa
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "member_id": member_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/members/dangerously_get/{member_id}", data
        )
        res = self.sync_client.get(url, data, headers)
        return GetResponse.from_json(res.response.status_code, res.json)

    async def dangerously_get_async(
        self,
        member_id: str,
    ) -> GetResponse:
        """Get a Member by `member_id`. This endpoint does not require an `organization_id`, enabling you to get members across organizations. This is a dangerous operation. Incorrect use may open you up to indirect object reference (IDOR) attacks. We recommend using the [Get Member](https://stytch.com/docs/b2b/api/get-member) API instead.

        Fields:
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
        """  # noqa
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "member_id": member_id,
        }

        url = self.api_base.url_for(
            "/v1/b2b/organizations/members/dangerously_get/{member_id}", data
        )
        res = await self.async_client.get(url, data, headers)
        return GetResponse.from_json(res.response.status, res.json)

    def create(
        self,
        organization_id: str,
        email_address: str,
        name: Optional[str] = None,
        trusted_metadata: Optional[Dict[str, Any]] = None,
        untrusted_metadata: Optional[Dict[str, Any]] = None,
        create_member_as_pending: Optional[bool] = None,
        is_breakglass: Optional[bool] = None,
        mfa_phone_number: Optional[str] = None,
        mfa_enrolled: Optional[bool] = None,
        roles: Optional[List[str]] = None,
        method_options: Optional[CreateRequestOptions] = None,
    ) -> CreateResponse:
        """Creates a Member. An `organization_id` and `email_address` are required. /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - email_address: The email address of the Member.
          - name: The name of the Member.
          - trusted_metadata: An arbitrary JSON object for storing application-specific data or identity-provider-specific data.
          - untrusted_metadata: An arbitrary JSON object of application-specific data. These fields can be edited directly by the
          frontend SDK, and should not be used to store critical information. See the [Metadata resource](https://stytch.com/docs/b2b/api/metadata)
          for complete field behavior details.
          - create_member_as_pending: Flag for whether or not to save a Member as `pending` or `active` in Stytch. It defaults to false. If true, new Members will be created with status `pending` in Stytch's backend. Their status will remain `pending` and they will continue to receive signup email templates for every Email Magic Link until that Member authenticates and becomes `active`. If false, new Members will be created with status `active`.
          - is_breakglass: Identifies the Member as a break glass user - someone who has permissions to authenticate into an Organization by bypassing the Organization's settings. A break glass account is typically used for emergency purposes to gain access outside of normal authentication procedures. Refer to the [Organization object](organization-object) and its `auth_methods` and `allowed_auth_methods` fields for more details.
          - mfa_phone_number: The Member's phone number. A Member may only have one phone number.
          - mfa_enrolled: Sets whether the Member is enrolled in MFA. If true, the Member must complete an MFA step whenever they wish to log in to their Organization. If false, the Member only needs to complete an MFA step if the Organization's MFA policy is set to `REQUIRED_FOR_ALL`.
          - roles: (Coming Soon) Roles to explicitly assign to this Member. See the [RBAC guide](https://stytch.com/docs/b2b/guides/rbac/role-assignment)
           for more information about role assignment.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "email_address": email_address,
        }
        if name is not None:
            data["name"] = name
        if trusted_metadata is not None:
            data["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            data["untrusted_metadata"] = untrusted_metadata
        if create_member_as_pending is not None:
            data["create_member_as_pending"] = create_member_as_pending
        if is_breakglass is not None:
            data["is_breakglass"] = is_breakglass
        if mfa_phone_number is not None:
            data["mfa_phone_number"] = mfa_phone_number
        if mfa_enrolled is not None:
            data["mfa_enrolled"] = mfa_enrolled
        if roles is not None:
            data["roles"] = roles

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members", data
        )
        res = self.sync_client.post(url, data, headers)
        return CreateResponse.from_json(res.response.status_code, res.json)

    async def create_async(
        self,
        organization_id: str,
        email_address: str,
        name: Optional[str] = None,
        trusted_metadata: Optional[Dict[str, Any]] = None,
        untrusted_metadata: Optional[Dict[str, Any]] = None,
        create_member_as_pending: Optional[bool] = None,
        is_breakglass: Optional[bool] = None,
        mfa_phone_number: Optional[str] = None,
        mfa_enrolled: Optional[bool] = None,
        roles: Optional[List[str]] = None,
        method_options: Optional[CreateRequestOptions] = None,
    ) -> CreateResponse:
        """Creates a Member. An `organization_id` and `email_address` are required. /%}

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - email_address: The email address of the Member.
          - name: The name of the Member.
          - trusted_metadata: An arbitrary JSON object for storing application-specific data or identity-provider-specific data.
          - untrusted_metadata: An arbitrary JSON object of application-specific data. These fields can be edited directly by the
          frontend SDK, and should not be used to store critical information. See the [Metadata resource](https://stytch.com/docs/b2b/api/metadata)
          for complete field behavior details.
          - create_member_as_pending: Flag for whether or not to save a Member as `pending` or `active` in Stytch. It defaults to false. If true, new Members will be created with status `pending` in Stytch's backend. Their status will remain `pending` and they will continue to receive signup email templates for every Email Magic Link until that Member authenticates and becomes `active`. If false, new Members will be created with status `active`.
          - is_breakglass: Identifies the Member as a break glass user - someone who has permissions to authenticate into an Organization by bypassing the Organization's settings. A break glass account is typically used for emergency purposes to gain access outside of normal authentication procedures. Refer to the [Organization object](organization-object) and its `auth_methods` and `allowed_auth_methods` fields for more details.
          - mfa_phone_number: The Member's phone number. A Member may only have one phone number.
          - mfa_enrolled: Sets whether the Member is enrolled in MFA. If true, the Member must complete an MFA step whenever they wish to log in to their Organization. If false, the Member only needs to complete an MFA step if the Organization's MFA policy is set to `REQUIRED_FOR_ALL`.
          - roles: (Coming Soon) Roles to explicitly assign to this Member. See the [RBAC guide](https://stytch.com/docs/b2b/guides/rbac/role-assignment)
           for more information about role assignment.
        """  # noqa
        headers: Dict[str, str] = {}
        if method_options is not None:
            headers = method_options.add_headers(headers)
        data: Dict[str, Any] = {
            "organization_id": organization_id,
            "email_address": email_address,
        }
        if name is not None:
            data["name"] = name
        if trusted_metadata is not None:
            data["trusted_metadata"] = trusted_metadata
        if untrusted_metadata is not None:
            data["untrusted_metadata"] = untrusted_metadata
        if create_member_as_pending is not None:
            data["create_member_as_pending"] = create_member_as_pending
        if is_breakglass is not None:
            data["is_breakglass"] = is_breakglass
        if mfa_phone_number is not None:
            data["mfa_phone_number"] = mfa_phone_number
        if mfa_enrolled is not None:
            data["mfa_enrolled"] = mfa_enrolled
        if roles is not None:
            data["roles"] = roles

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/members", data
        )
        res = await self.async_client.post(url, data, headers)
        return CreateResponse.from_json(res.response.status, res.json)

    def get(
        self,
        organization_id: str,
        member_id: Optional[str] = None,
        email_address: Optional[str] = None,
    ) -> GetResponse:
        """Get a Member by `member_id` or `email_address`.

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
          - email_address: The email address of the Member.
        """  # noqa
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "organization_id": organization_id,
        }
        if member_id is not None:
            data["member_id"] = member_id
        if email_address is not None:
            data["email_address"] = email_address

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/member", data
        )
        res = self.sync_client.get(url, data, headers)
        return GetResponse.from_json(res.response.status_code, res.json)

    async def get_async(
        self,
        organization_id: str,
        member_id: Optional[str] = None,
        email_address: Optional[str] = None,
    ) -> GetResponse:
        """Get a Member by `member_id` or `email_address`.

        Fields:
          - organization_id: Globally unique UUID that identifies a specific Organization. The `organization_id` is critical to perform operations on an Organization, so be sure to preserve this value.
          - member_id: Globally unique UUID that identifies a specific Member. The `member_id` is critical to perform operations on a Member, so be sure to preserve this value.
          - email_address: The email address of the Member.
        """  # noqa
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "organization_id": organization_id,
        }
        if member_id is not None:
            data["member_id"] = member_id
        if email_address is not None:
            data["email_address"] = email_address

        url = self.api_base.url_for(
            "/v1/b2b/organizations/{organization_id}/member", data
        )
        res = await self.async_client.get(url, data, headers)
        return GetResponse.from_json(res.response.status, res.json)
