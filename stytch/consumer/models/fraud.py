# !!!
# WARNING: This file is autogenerated
# Only modify code within MANUAL() sections
# or your changes may be overwritten later!
# !!!

from __future__ import annotations

import datetime
import enum
from typing import List, Optional

import pydantic


class RuleAction(str, enum.Enum):
    ALLOW = "ALLOW"
    CHALLENGE = "CHALLENGE"
    BLOCK = "BLOCK"
    NONE = "NONE"


class RuleType(str, enum.Enum):
    VISITOR_ID = "VISITOR_ID"
    BROWSER_ID = "BROWSER_ID"
    VISITOR_FINGERPRINT = "VISITOR_FINGERPRINT"
    BROWSER_FINGERPRINT = "BROWSER_FINGERPRINT"
    HARDWARE_FINGERPRINT = "HARDWARE_FINGERPRINT"
    NETWORK_FINGERPRINT = "NETWORK_FINGERPRINT"
    CIDR_BLOCK = "CIDR_BLOCK"
    ASN = "ASN"
    COUNTRY_CODE = "COUNTRY_CODE"


class VerdictAction(str, enum.Enum):
    ALLOW = "ALLOW"
    CHALLENGE = "CHALLENGE"
    BLOCK = "BLOCK"


class VerdictReasonActionAction(str, enum.Enum):
    ALLOW = "ALLOW"
    CHALLENGE = "CHALLENGE"
    BLOCK = "BLOCK"


class VerdictReasonOverrideAction(str, enum.Enum):
    ALLOW = "ALLOW"
    CHALLENGE = "CHALLENGE"
    BLOCK = "BLOCK"


class ASNProperties(pydantic.BaseModel):
    """
    Fields:
      - asn: The Autonomous System Number of the user's network.
      - name: Public name associated with the ASN.
      - network: The CIDR block associated with the ASN.
    """  # noqa

    asn: str
    name: str
    network: str


class BrowserProperties(pydantic.BaseModel):
    """
    Fields:
      - user_agent: The user agent of the user's browser.
    """  # noqa

    user_agent: str


class Fingerprints(pydantic.BaseModel):
    """
    Fields:
      - network_fingerprint: Combination of signals associated with a specific network commonly known as TLS fingerprinting.
      - hardware_fingerprint: Combinations of signals to identify an operating system and architecture.
      - browser_fingerprint: Combination of signals to identify a browser and its specific version.
      - visitor_fingerprint: Cookie-less way of identifying a unique user.
      - visitor_id: The cookie stored on the user's device that uniquely identifies them. See the Device Fingerprinting documentation for more details on the visitor_id.
      - browser_id: Combination of VisitorID and NetworkFingerprint to create a clear identifier of a browser.
    """  # noqa

    network_fingerprint: str
    hardware_fingerprint: str
    browser_fingerprint: str
    visitor_fingerprint: str
    visitor_id: Optional[str] = None
    browser_id: Optional[str] = None


class IPGeoProperties(pydantic.BaseModel):
    """
    Fields:
      - city: The city where the IP is located.
      - region: The region where the IP is located.
      - country: The country where the IP is located.
    """  # noqa

    city: str
    region: str
    country: str


class Metadata(pydantic.BaseModel):
    """
    Fields:
      - external_id: An external ID, such as a user ID, that you wish to associate with the telemetry ID.
      - organization_id: The organization ID you wish to associate with the telemetry ID.
      - user_action: The user action, such as 'login', that you wish to associate with the telemetry ID.
    """  # noqa

    external_id: Optional[str] = None
    organization_id: Optional[str] = None
    user_action: Optional[str] = None


class NetworkProperties(pydantic.BaseModel):
    """
    Fields:
      - ip_address: The IP address from which the request originated.
      - asn: The Autonomous System Number of the user's network.
      - ip_geolocation: Geographic location data derived from the IP address.
      - is_proxy: A boolean indicating whether the request came through a proxy server.
      - is_vpn: A boolean indicating whether the request originated from a VPN or proxy network.
    """  # noqa

    ip_address: str
    asn: ASNProperties
    ip_geolocation: IPGeoProperties
    is_proxy: bool
    is_vpn: bool


class Properties(pydantic.BaseModel):
    """
    Fields:
      - network_properties: Network properties including IP address, ASN information, geolocation, and proxy/VPN detection.
      - browser_properties: Browser properties including user agent and other browser-specific information.
    """  # noqa

    network_properties: NetworkProperties
    browser_properties: BrowserProperties


class Rule(pydantic.BaseModel):
    """
    Fields:
      - rule_type: The rule type. The possible values are `VISITOR_ID`, `BROWSER_ID`, `VISITOR_FINGERPRINT`, `BROWSER_FINGERPRINT`,`HARDWARE_FINGERPRINT`, `NETWORK_FINGERPRINT`, `CIDR_BLOCK`, `ASN`, or `COUNTRY_CODE`.
      - action: The action that should be returned by a fingerprint lookup for that identifier with a `RULE_MATCH` reason. The following values are valid: `ALLOW` (This is a known valid device grouping or device profile that is part of the default ALLOW listed set of known devices by Stytch), `BLOCK` (This is a known bad or malicious device profile that is undesirable and should be blocked from completing the privileged action), `CHALLENGE` (This is an unknown or potentially malicious device that should be put through increased friction such as 2FA or other forms of extended user verification before allowing the privileged action), or `NONE`. For country codes, `ALLOW` actions are not allowed. If a `NONE` action is specified, it will clear the stored rule.
      - created_at: The timestamp indicating when the resource was created.
      - visitor_id: The cookie stored on the user's device that uniquely identifies them. See the Device Fingerprinting documentation for more details on the visitor_id.
      - browser_id: Combination of VisitorID and NetworkFingerprint to create a clear identifier of a browser.
      - visitor_fingerprint: Cookie-less way of identifying a unique user.
      - browser_fingerprint: Combination of signals to identify a browser and its specific version.
      - hardware_fingerprint: Combinations of signals to identify an operating system and architecture.
      - network_fingerprint: Combination of signals associated with a specific network commonly known as TLS fingerprinting.
      - cidr_block: The CIDR block that a rule was set for. If an end user's IP address is within this CIDR block, this rule will be applied.
      - country_code: The country code we want to set a rule for. The country code must be a valid ISO 3166-1 alpha-2 code. You may not set `ALLOW` rules for country codes. Only one identifier can be specified in the request.
      - asn: The Autonomous System Number of the user's network.
      - description: An optional description for the rule.
      - expires_at: The timestamp when the rule expires.
      - last_updated_at: The timestamp when the resource was last updated.
    """  # noqa

    rule_type: RuleType
    action: RuleAction
    created_at: datetime.datetime
    visitor_id: Optional[str] = None
    browser_id: Optional[str] = None
    visitor_fingerprint: Optional[str] = None
    browser_fingerprint: Optional[str] = None
    hardware_fingerprint: Optional[str] = None
    network_fingerprint: Optional[str] = None
    cidr_block: Optional[str] = None
    country_code: Optional[str] = None
    asn: Optional[str] = None
    description: Optional[str] = None
    expires_at: Optional[datetime.datetime] = None
    last_updated_at: Optional[datetime.datetime] = None


class VerdictReasonAction(pydantic.BaseModel):
    """
    Fields:
      - verdict_reason: A human-readable explanation of why an authorization decision was made.
      - default_action: The default action returned for the specified verdict reason in a fingerprint lookup when no overrides are specified.
      - override_action: If not null, this action will be returned for the specified verdict reason in a fingerprint lookup, in place of the default action.
      - override_created_at: The time when the override was created, if one exists.
      - override_description: A description of the override, if one exists.
    """  # noqa

    verdict_reason: str
    default_action: VerdictReasonActionAction
    override_action: Optional[VerdictReasonActionAction] = None
    override_created_at: Optional[datetime.datetime] = None
    override_description: Optional[str] = None


class VerdictReasonOverride(pydantic.BaseModel):
    """
    Fields:
      - verdict_reason: A human-readable explanation of why an authorization decision was made.
      - override_action: The action that was applied for the given verdict reason.
    """  # noqa

    verdict_reason: str
    override_action: VerdictReasonOverrideAction


class Verdict(pydantic.BaseModel):
    """
    Fields:
      - action: The action that should be returned by a fingerprint lookup for that identifier with a `RULE_MATCH` reason. The following values are valid: `ALLOW` (This is a known valid device grouping or device profile that is part of the default ALLOW listed set of known devices by Stytch), `BLOCK` (This is a known bad or malicious device profile that is undesirable and should be blocked from completing the privileged action), `CHALLENGE` (This is an unknown or potentially malicious device that should be put through increased friction such as 2FA or other forms of extended user verification before allowing the privileged action), or `NONE`. For country codes, `ALLOW` actions are not allowed. If a `NONE` action is specified, it will clear the stored rule.
      - reasons: A set of contextual clues to inform why a `CHALLENGE` or `BLOCK` action was suggested. For a list of possible reasons, see [Warning Flags (Verdict Reasons)](https://stytch.com/docs/docs/fraud/guides/device-fingerprinting/reference/warning-flags-verdict-reasons).
      - detected_device_type: The operating system and architecture tha took the fingerprint.
      - is_authentic_device: A boolean indicating whether the device has been verified as authentic and trustworthy. It will be false if hardware or browser deception is detected.
      - verdict_reason_overrides: A list of verdict reason overrides that were applied, if any.
      - rule_match_type: The type of rule match that was applied (e.g. `VISITOR_ID`), if any. This field will only be present if there is a `RULE_MATCH` reason in the list of verdict reasons.
      - rule_match_identifier: The rule that was applied (e.g. a specific visitor ID value), if any. This field will only be present if there is a `RULE_MATCH` reason in the list of verdict reasons.
    """  # noqa

    action: VerdictAction
    reasons: List[str]
    detected_device_type: str
    is_authentic_device: bool
    verdict_reason_overrides: List[VerdictReasonOverride]
    rule_match_type: Optional[RuleType] = None
    rule_match_identifier: Optional[str] = None
