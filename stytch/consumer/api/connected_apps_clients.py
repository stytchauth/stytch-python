# !!!
# WARNING: This file is autogenerated
# Only modify code within MANUAL() sections
# or your changes may be overwritten later!
# !!!

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from stytch.consumer.api.connected_apps_clients_secrets import Secrets
from stytch.consumer.models.connected_apps_clients import (
    CreateRequestClientType,
    CreateResponse,
    DeleteResponse,
    GetResponse,
    SearchResponse,
    UpdateResponse,
)
from stytch.core.api_base import ApiBase
from stytch.core.http.client import AsyncClient, SyncClient


class Clients:
    def __init__(
        self, api_base: ApiBase, sync_client: SyncClient, async_client: AsyncClient
    ) -> None:
        self.api_base = api_base
        self.sync_client = sync_client
        self.async_client = async_client
        self.secrets = Secrets(
            api_base=self.api_base,
            sync_client=self.sync_client,
            async_client=self.async_client,
        )

    def get(
        self,
        client_id: str,
    ) -> GetResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "client_id": client_id,
        }

        url = self.api_base.url_for("/v1/connected_apps/clients/{client_id}", data)
        res = self.sync_client.get(url, data, headers)
        return GetResponse.from_json(res.response.status_code, res.json)

    async def get_async(
        self,
        client_id: str,
    ) -> GetResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "client_id": client_id,
        }

        url = self.api_base.url_for("/v1/connected_apps/clients/{client_id}", data)
        res = await self.async_client.get(url, data, headers)
        return GetResponse.from_json(res.response.status, res.json)

    def update(
        self,
        client_id: str,
        client_name: Optional[str] = None,
        client_description: Optional[str] = None,
        redirect_urls: Optional[List[str]] = None,
        full_access_allowed: Optional[bool] = None,
        access_token_expiry_minutes: Optional[int] = None,
        access_token_custom_audience: Optional[str] = None,
        access_token_template_content: Optional[str] = None,
        post_logout_redirect_urls: Optional[List[str]] = None,
        logo_url: Optional[str] = None,
        bypass_consent_for_offline_access: Optional[bool] = None,
    ) -> UpdateResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "client_id": client_id,
        }
        if client_name is not None:
            data["client_name"] = client_name
        if client_description is not None:
            data["client_description"] = client_description
        if redirect_urls is not None:
            data["redirect_urls"] = redirect_urls
        if full_access_allowed is not None:
            data["full_access_allowed"] = full_access_allowed
        if access_token_expiry_minutes is not None:
            data["access_token_expiry_minutes"] = access_token_expiry_minutes
        if access_token_custom_audience is not None:
            data["access_token_custom_audience"] = access_token_custom_audience
        if access_token_template_content is not None:
            data["access_token_template_content"] = access_token_template_content
        if post_logout_redirect_urls is not None:
            data["post_logout_redirect_urls"] = post_logout_redirect_urls
        if logo_url is not None:
            data["logo_url"] = logo_url
        if bypass_consent_for_offline_access is not None:
            data["bypass_consent_for_offline_access"] = (
                bypass_consent_for_offline_access
            )

        url = self.api_base.url_for("/v1/connected_apps/clients/{client_id}", data)
        res = self.sync_client.put(url, data, headers)
        return UpdateResponse.from_json(res.response.status_code, res.json)

    async def update_async(
        self,
        client_id: str,
        client_name: Optional[str] = None,
        client_description: Optional[str] = None,
        redirect_urls: Optional[List[str]] = None,
        full_access_allowed: Optional[bool] = None,
        access_token_expiry_minutes: Optional[int] = None,
        access_token_custom_audience: Optional[str] = None,
        access_token_template_content: Optional[str] = None,
        post_logout_redirect_urls: Optional[List[str]] = None,
        logo_url: Optional[str] = None,
        bypass_consent_for_offline_access: Optional[bool] = None,
    ) -> UpdateResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "client_id": client_id,
        }
        if client_name is not None:
            data["client_name"] = client_name
        if client_description is not None:
            data["client_description"] = client_description
        if redirect_urls is not None:
            data["redirect_urls"] = redirect_urls
        if full_access_allowed is not None:
            data["full_access_allowed"] = full_access_allowed
        if access_token_expiry_minutes is not None:
            data["access_token_expiry_minutes"] = access_token_expiry_minutes
        if access_token_custom_audience is not None:
            data["access_token_custom_audience"] = access_token_custom_audience
        if access_token_template_content is not None:
            data["access_token_template_content"] = access_token_template_content
        if post_logout_redirect_urls is not None:
            data["post_logout_redirect_urls"] = post_logout_redirect_urls
        if logo_url is not None:
            data["logo_url"] = logo_url
        if bypass_consent_for_offline_access is not None:
            data["bypass_consent_for_offline_access"] = (
                bypass_consent_for_offline_access
            )

        url = self.api_base.url_for("/v1/connected_apps/clients/{client_id}", data)
        res = await self.async_client.put(url, data, headers)
        return UpdateResponse.from_json(res.response.status, res.json)

    def delete(
        self,
        client_id: str,
    ) -> DeleteResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "client_id": client_id,
        }

        url = self.api_base.url_for("/v1/connected_apps/clients/{client_id}", data)
        res = self.sync_client.delete(url, headers)
        return DeleteResponse.from_json(res.response.status_code, res.json)

    async def delete_async(
        self,
        client_id: str,
    ) -> DeleteResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "client_id": client_id,
        }

        url = self.api_base.url_for("/v1/connected_apps/clients/{client_id}", data)
        res = await self.async_client.delete(url, headers)
        return DeleteResponse.from_json(res.response.status, res.json)

    def search(
        self,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> SearchResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {}
        if cursor is not None:
            data["cursor"] = cursor
        if limit is not None:
            data["limit"] = limit

        url = self.api_base.url_for("/v1/connected_apps/clients/search", data)
        res = self.sync_client.post(url, data, headers)
        return SearchResponse.from_json(res.response.status_code, res.json)

    async def search_async(
        self,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> SearchResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {}
        if cursor is not None:
            data["cursor"] = cursor
        if limit is not None:
            data["limit"] = limit

        url = self.api_base.url_for("/v1/connected_apps/clients/search", data)
        res = await self.async_client.post(url, data, headers)
        return SearchResponse.from_json(res.response.status, res.json)

    def create(
        self,
        client_type: Union[CreateRequestClientType, str],
        redirect_urls: List[str],
        full_access_allowed: bool,
        post_logout_redirect_urls: List[str],
        client_name: Optional[str] = None,
        client_description: Optional[str] = None,
        access_token_expiry_minutes: Optional[int] = None,
        access_token_custom_audience: Optional[str] = None,
        access_token_template_content: Optional[str] = None,
        logo_url: Optional[str] = None,
        bypass_consent_for_offline_access: Optional[bool] = None,
    ) -> CreateResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "client_type": client_type,
            "redirect_urls": redirect_urls,
            "full_access_allowed": full_access_allowed,
            "post_logout_redirect_urls": post_logout_redirect_urls,
        }
        if client_name is not None:
            data["client_name"] = client_name
        if client_description is not None:
            data["client_description"] = client_description
        if access_token_expiry_minutes is not None:
            data["access_token_expiry_minutes"] = access_token_expiry_minutes
        if access_token_custom_audience is not None:
            data["access_token_custom_audience"] = access_token_custom_audience
        if access_token_template_content is not None:
            data["access_token_template_content"] = access_token_template_content
        if logo_url is not None:
            data["logo_url"] = logo_url
        if bypass_consent_for_offline_access is not None:
            data["bypass_consent_for_offline_access"] = (
                bypass_consent_for_offline_access
            )

        url = self.api_base.url_for("/v1/connected_apps/clients", data)
        res = self.sync_client.post(url, data, headers)
        return CreateResponse.from_json(res.response.status_code, res.json)

    async def create_async(
        self,
        client_type: CreateRequestClientType,
        redirect_urls: List[str],
        full_access_allowed: bool,
        post_logout_redirect_urls: List[str],
        client_name: Optional[str] = None,
        client_description: Optional[str] = None,
        access_token_expiry_minutes: Optional[int] = None,
        access_token_custom_audience: Optional[str] = None,
        access_token_template_content: Optional[str] = None,
        logo_url: Optional[str] = None,
        bypass_consent_for_offline_access: Optional[bool] = None,
    ) -> CreateResponse:
        headers: Dict[str, str] = {}
        data: Dict[str, Any] = {
            "client_type": client_type,
            "redirect_urls": redirect_urls,
            "full_access_allowed": full_access_allowed,
            "post_logout_redirect_urls": post_logout_redirect_urls,
        }
        if client_name is not None:
            data["client_name"] = client_name
        if client_description is not None:
            data["client_description"] = client_description
        if access_token_expiry_minutes is not None:
            data["access_token_expiry_minutes"] = access_token_expiry_minutes
        if access_token_custom_audience is not None:
            data["access_token_custom_audience"] = access_token_custom_audience
        if access_token_template_content is not None:
            data["access_token_template_content"] = access_token_template_content
        if logo_url is not None:
            data["logo_url"] = logo_url
        if bypass_consent_for_offline_access is not None:
            data["bypass_consent_for_offline_access"] = (
                bypass_consent_for_offline_access
            )

        url = self.api_base.url_for("/v1/connected_apps/clients", data)
        res = await self.async_client.post(url, data, headers)
        return CreateResponse.from_json(res.response.status, res.json)
